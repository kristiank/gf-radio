module Main where

  import PGF
  import Radiology   -- generated automatically: gf -make --output-format=haskell RadiologyEng.gf

  main :: IO ()
  main = do
    gr <- readPGF "Radiology.pgf" -- generated by gf -make RadiologyEng.gf
    putStrLn "Write your sentence here, I will try to aggregate it."
    putStrLn "Write quit to exit."
    loop (translate transfer gr)

  loop :: (String -> [String]) -> IO ()
  loop trans = do
    putStr "> "
    s <- getLine
    if s == "quit" then putStrLn "bye" else do
      mapM_ putStrLn $ trans s
      loop trans

  translate :: (Tree -> [Tree]) -> PGF -> String -> [String]
  translate tr gr s = case parseAllLang gr (startCat gr) s of
    (lg,t:_):_ -> map (linearize gr lg) (tr t)
    _ -> ["NO PARSE"]

  transfer :: Tree -> [Tree]
  transfer = map gf . normalize funs . fg
   where funs = [aggregateDescn, verboseDescn]

----------------------------------------------------
-- Transfer functions

  normalize :: [GDescription -> GDescription] -> GStatement -> [GStatement]
  normalize fs st = case st of
    GPred org descn -> [GPred org (f descn) | f <- fs]

  aggregateDescn :: GDescription -> GDescription
  aggregateDescn descn = case descn of
    GDesc2 dn1 dn2 -> aggregateDescn2 dn1 dn2
    GDesc3 dn1 dn2 dn3 -> aggregateDescn3 dn1 dn2 dn3
    _ -> descn

  aggregateDescn2 :: GDescription -> GDescription -> GDescription
  aggregateDescn2 dn1@(GDescribePos dr1 p1 proof1) dn2@(GDescribePos dr2 p2 proof2)
    | show dr1 == show dr2 && show p1 == show p2 = dn1
    | show dr1 == show dr2 = GAggregateProperty2Pos dr1 p1 p2 proof1 proof2
    | otherwise = GDesc2 dn1 dn2
  aggregateDescn2 dn1@(GDescribeNeg dr1 p1 proof1) dn2@(GDescribeNeg dr2 p2 proof2)
    | show dr1 == show dr2 && show p1 == show p2 = dn1
    | show dr1 == show dr2 = GAggregateProperty2Neg dr1 p1 p2 proof1 proof2
    | otherwise = GDesc2 dn1 dn2
  aggregateDescn2 dn1 dn2 = GDesc2 dn1 dn2


  aggregateDescn3 :: GDescription -> GDescription -> GDescription -> GDescription
  aggregateDescn3 dn1@(GDescribePos dr1 p1 proof1) dn2@(GDescribePos dr2 p2 proof2) dn3@(GDescribePos dr3 p3 proof3)
    | show dr1 == show dr2 = GDesc2 (GAggregateProperty2Pos dr1 p1 p2 proof1 proof2) dn3
    | show dr1 == show dr3 = GDesc2 (GAggregateProperty2Pos dr1 p1 p3 proof1 proof3) dn2
    | show dr2 == show dr3 = GDesc2 (GAggregateProperty2Pos dr1 p2 p3 proof2 proof3) dn1
    | otherwise = GDesc3 dn1 dn2 dn3
  aggregateDescn3 dn1@(GDescribeNeg dr1 p1 proof1) dn2@(GDescribeNeg dr2 p2 proof2) dn3@(GDescribeNeg dr3 p3 proof3)
    | show dr1 == show dr2 = GDesc2 (GAggregateProperty2Neg dr1 p1 p2 proof1 proof2) dn3
    | show dr1 == show dr3 = GDesc2 (GAggregateProperty2Neg dr1 p1 p3 proof1 proof3) dn2
    | show dr2 == show dr3 = GDesc2 (GAggregateProperty2Neg dr1 p2 p3 proof2 proof3) dn1
    | otherwise = GDesc3 dn1 dn2 dn3
  aggregateDescn3 dn1 dn2 dn3 = GDesc3 dn1 dn2 dn3

  verboseDescn :: GDescription -> GDescription
  verboseDescn descn = case descn of
    GAggregateProperty2Pos descr p1 p2 proof1 proof2 -> GDesc2 (GDescribePos descr p1 proof1) (GDescribePos descr p2 proof2)
    GAggregateProperty2Neg descr p1 p2 proof1 proof2 -> GDesc2 (GDescribeNeg descr p1 proof1) (GDescribeNeg descr p2 proof2)
    _ -> descn
